# ðŸ¦€ Rust & Diesel Deep Dive Pop Quiz

## Multiple Choice Questions (10 questions)

### 1. What is the primary purpose of the `#[derive(Queryable)]` attribute in Diesel?
A) It automatically generates SQL queries
B) It allows a struct to be returned from database queries
C) It creates database migrations
D) It validates database connections

**Answer:** B

### 2. In Diesel, what does the `schema::` module contain?
A) Database connection configuration
B) Auto-generated table definitions and column references
C) Custom SQL queries
D) Migration files

**Answer:** B

### 3. When using Diesel with Axum, what is the correct pattern for getting a mutable database connection?
A) `let conn = pool.get()?`
B) `let mut conn = pool.get().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?`
C) `let conn = pool.acquire().await?`
D) `let mut conn = pool.borrow_mut()?`

**Answer:** ~~D~~ B 
Yeahh. I thought this was B at first but then remembered somewhere else where we added a function containing the `_mut()` keyword and I got mixed up here. Also this is a similar question from the last quiz. Tsk.

### 4. What is the purpose of the `#[derive(Insertable)]` attribute in Diesel?
A) It allows inserting data into the database
B) It validates data before insertion
C) It creates database tables
D) It handles database transactions

**Answer:** A

### 5. In our MTG deck builder, what does the `DeckCard` struct represent?
A) A single Magic card
B) A user's deck collection
C) A join table relationship between decks and cards with quantities
D) A database migration

**Answer:** C

### 6. What is the correct way to filter a Diesel query by a foreign key?
A) `.filter(decks::user_id.eq(user_id_value))`
B) `.where(user_id = user_id_value)`
C) `.filter(user_id.eq(user_id_value))`
D) `.select().where(user_id == user_id_value)`

**Answer:** ~~C~~ A
Have to remember that the `user_id` variable isn't available everywhere. Unless we bring it into scope, we have to call out that it is something from our schema/deck object.

Still getting used to this syntax.

### 7. What does the `type DbPool = Pool<ConnectionManager<PgConnection>>;` alias accomplish?
A) It creates a new database connection type
B) It simplifies the complex connection pool type for readability
C) It changes the database from PostgreSQL to MySQL
D) It enables connection pooling

**Answer:** B

### 8. In Diesel migrations, what is the purpose of the `up.sql` file?
A) It contains the SQL to rollback changes
B) It contains the SQL to apply the migration
C) It validates the migration syntax
D) It creates the migration timestamp

**Answer:** B

### 9. What is the purpose of the `#[derive(AsChangeset)]` attribute in Diesel?
A) It allows updating existing database records
B) It tracks changes to database schema
C) It validates data changes
D) It creates database indexes

**Answer:** A

### 10. In our project, what does the `MtgFormat` enum represent?
A) Different types of Magic cards
B) Different Magic tournament formats (Standard, Modern, etc.)
C) Different database connection types
D) Different API response formats

**Answer:** B

---

## Short Answer Questions (5 questions)

### 1. Explain the difference between `Queryable`, `Insertable`, and `AsChangeset` derives in Diesel. When would you use each one?

**Answer:** `Queryable` means the entry can be returned from a database query like for selects. `Insertable` means the entry can be inserted into a database table like for adding new entries into the database.

### 2. Describe the relationship between the `User`, `Deck`, and `DeckCard` models in our MTG deck builder. How does this represent a many-to-many relationship with additional data?

**Answer:** `User` is the user profile and can be gotten from the `users` table. `Deck` is the deck profile entry and can be gotten from the `decks` table. `DeckCard` serves as a relationship entity between the `Deck` entity and the `Card` entity. It will contain foreign keys to both the `Deck` entity and the `Card` in order to achieve this. `Deck` also contains a foreign key from the `User` entity as decks belong to users. 

To graph it out. 

user -> deck (contains many cards)
     -> deck (contains many cards)
     -> deck (contains many cards)

### 3. What is the purpose of the `r2d2` connection pool in our application? Explain the benefits of connection pooling and how it differs from creating new connections for each request.

**Answer:** Efficiency! A single connection to a database can handle multiple requests adjusting that database. Our limit now is 10 but we will see if we can handle more in the future. 

Making a connection is expensive if we were to do it for every single call. Dropping the connection each time the call is done is wasteful as we could have done so much more with that connection before it was terminated. A pool simply represents a single primary connection to a database which then allows multiple sub-connections at a single time.

### 4. In our code, we use `State<DbPool>` in Axum handlers. Explain how this provides type-safe access to the database connection pool and why this is better than global variables.

**Answer:** This allows us to connect `State<DbPool>` to our application so that it knows what connection it is using for its calls. This seems like a repeat question from the last quiz! `(*3*)` 

### 5. Describe the process of creating and running a Diesel migration. What files are created, what do they contain, and how does Diesel use them to manage database schema changes?

**Answer:** Diesel generates "up" and "down" sql contained within files `up.sql` and `down.sql` simply. These are the scripts that the server will run to update the database should it need an update to a new schema or be intially created. Up scripts are for upgrades/intialization and down is for rolling back changes. 

Those are the migration files themselves. When we run them, Diesel not only does this within our database but it also creates `schema.rs` which stands as the connections between our tables in Rust format for the compiler to be able to check for various operations.

---

## Advanced Diesel Questions (3 questions)

### 1. How would you implement a complex query that joins the `decks`, `deck_cards`, and `cards` tables to get all cards in a specific deck with their quantities?

**Answer:** I actually don't know this specific syntax at this point so I will take a swing in the dark. Probably something like. 

```rust
decks
    .join(deck_cards).on(deck.id == deck_cards.deck_id)
    .join(cards).on(cards.id == deck_cards.card_id)
    .select!(decks.quantities)
```

Just guessing though. Since I don't know the functions don't get too mad at me for not knowing. I understand the connections through SQL though and understand SQL well enough. 

**Correct syntax**

```rust
decks::table
    .inner_join(deck_cards::table.on(decks::id.eq(deck_cards::deck_id)))
    .inner_join(cards::table.on(cards::id.eq(deck_cards::card_id)))
    .filter(decks::id.eq(deck_id))
    .select((cards::all_columns, deck_cards::quantity))
```

without names for coneptual readability...

```rust
table_1
    .inner_join(table_2.on(id_1.eq(id_2)))
    .inner_join(table_3.on(id_3.eq(id_4)))
    .filter(column.eq(value))
    .select((table_1::all_columns, table_2::column_name))
```

### 2. Explain the concept of "check_for_backend" in Diesel. Why is this important when working with different database backends, and how does it affect our PostgreSQL implementation?

**Answer:** `check_for_backend` basically checks that the columns declared in struct 1. have a matching column in the correlating table declaration in `schema.rs` and 2. the datatype in the struct maps well to the datatype of the column in SQL since we're basically telling the system how to translate two different programming languages from each other.

### 3. In our `MtgFormat` enum, we implemented custom `ToSql` and `FromSql` traits. Why was this necessary, and what would happen if we didn't implement these traits?

**Answer:** Because SQL doesn't have enums. We have to tell the system that when turning `MtgFormat` to SQL we build into a string value. And when coming from SQL we try to match the string coming from SQL to one of the selections in the `MtgFormat` enum. 

---

## Bonus Challenge Question

**Expert Level:** Explain how you would implement database transactions in our MTG deck builder. For example, when adding a card to a deck, you might need to:
1. Check if the deck exists
2. Verify the card exists
3. Check if the card is already in the deck
4. Insert or update the deck_card record
5. Update the deck's total card count

How would you ensure all these operations succeed or fail together?

**Answer:** I don't know all of the syntax so I will keep it high level. I might build an enum for the errors that we could experience while doing this but not sure if that is best practice yet, or something else would suffice. 

I know there is an `anyhow` crate which people often use in `.bin`s (I think--there might be another one that people use `thiserror`... but I feel like that is more for libraries) in order to build easier error handling code.

Anyway, I would build each function with proper error handling erroring out the entire function if they don't work checking each thing in order and then finally performing the operation and giving an `Ok(_)` of some sort to notify the user that the operation has been completed. 

We will get to this eventually. `:)`

---

*Quiz created based on Diesel ORM concepts, Rust database patterns, and MTG deck builder specific implementations covered throughout the development journey.* 