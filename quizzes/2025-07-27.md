# ðŸ¦€ Rust API Development Pop Quiz

## Multiple Choice Questions (10 questions)

### 1. What is the primary benefit of organizing handlers into separate modules in a Rust Axum application?
A) It makes the code compile faster
B) It reduces memory usage
C) It improves code organization, maintainability, and scalability
D) It automatically generates documentation

**Answer:** C

### 2. In Rust module organization, what does `pub mod cards;` in a `mod.rs` file do?
A) It creates a new module called "cards"
B) It makes the "cards" module public and available to other modules
C) It imports all functions from the cards module
D) It compiles the cards module separately

**Answer:** B

### 3. What is the purpose of the `DbPool` type alias in a Rust web application?
A) To make the code more readable by simplifying complex type names
B) To reduce memory allocation
C) To enable faster database queries
D) To automatically handle database migrations

**Answer:** A

### 4. When using Diesel with Axum, what pattern is used to get a database connection from the pool?
A) `pool.connect()` 
B) `pool.get().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?`
C) `pool.acquire()`
D) `pool.borrow()`

**Answer:** B

### 5. What is the main advantage of using `State<DbPool>` in Axum handler functions?
A) It automatically handles database transactions
B) It provides type-safe access to the database connection pool
C) It reduces the number of imports needed
D) It enables automatic connection pooling

**Answer:** B? Unsure on this one. I know that `State<DbPool>` is given to the Axum handler functions as an input type. I assume it has its own type because it will have its own methods to use and thus is a "type-safe" type of thing. Could be A as well depending on what we mean by "automatically"? As it gives us methods to use along with the type so that is useful. Final answer is B though.

### 6. In the context of API route organization, what does `handlers::cards::list_cards` represent?
A) A function call to list cards
B) A module path showing the exact location of the handler function
C) A database query
D) A middleware function

**Answer:**  B as it is not calling the function but handing off the function object to the function. Func-ception.

### 7. What is the primary purpose of separating health check endpoints from business logic endpoints?
A) To reduce compilation time
B) To enable different error handling for different endpoint types
C) To improve code organization and make testing easier
D) To reduce memory usage

**Answer:** C

### 8. When refactoring a large `main.rs` file, what is the recommended approach for organizing imports?
A) Put all imports at the top of each file
B) Group imports by category (std, external, internal) and only import what's needed
C) Use wildcard imports to reduce typing
D) Import everything in main.rs and pass it down

**Answer:** B. Depending on experience of building/reading you might not need to categorize but for me it helps understand what imports are for what.

### 9. What does the `#[tokio::main]` attribute do in a Rust async application?
A) It starts the Tokio runtime automatically
B) It enables async/await syntax
C) It configures the database connection
D) It sets up the web server

**Answer:** It tells the compiler that the main function is async. So the answer is B.

### 10. In the context of error handling in Axum handlers, what does `Result<Json<Value>, StatusCode>` represent?
A) A success response with JSON data or an HTTP error status
B) A database query result
C) A middleware chain
D) A connection pool status

**Answer:** It means that the function will return a `Result` enum with `Ok()` options being in `Json<Value>`and `Err()` options being in `StatusCode` data type. So the answer is A.

---

## Short Answer Questions (5 questions)

### 1. Explain the difference between a "shallow" health check and a "deep" health check in a web API. When would you use each?

**Answer:** In our case:
Shallow -> checks if the server is running. Deep -> checks various running conditions like database accessability, speed, results of certain test functions, etc.

It can mean different things for different apps but for us it is primarily these things. 

Maybe in the future shallow will also do database connection checking and the deeper version will do even more in-depth checks but for now it is this.

### 2. Describe the benefits of using explicit route naming like `handlers::cards::list_cards` instead of importing all handlers with `use crate::handlers::*`.

**Answer:** Explicit route naming is good so we don't bring more into scope than we need which would needlessly increase the compile overhead and result in unused imports (probably warnings during compile time as well). 

I could import specifically like `use handlers::*` as well and then just use `decks` or `cards` later but there are other things with those names so I want to keep the paths explicit.

### 3. What is the purpose of the `CorsLayer::permissive()` middleware in an Axum application, and why might you want to configure it more strictly in production?

**Answer:** `CorsLayer::permissive()` allows us to have some cors configuration present to remind us to build it in later. Not sure if it is actually needed during development to be honest. I know later we will build it to expect calls from our Flutter application.

### 4. Explain the concept of "separation of concerns" in the context of organizing Rust API code into modules. Give an example of how this principle was applied in the refactoring.

**Answer:** Certain jobs or functions can be categorized and organized into specific areas where we understand that handlers go in the handlers bucket and health checks go in the health bucket and auth functions go in the auth bucket. That doesn't explain it great so I will continue. 

We only have to bring in certain scopes of imports to serve a specific category of function. When we go to add new functions we know where to add them rather than create a huge dog pile in `main.rs`.

We know what roles and responsibilities each area serves so we know when we go to add new functionality where to add it. 

### 5. Describe the relationship between the `handlers/mod.rs` file and the individual handler files (like `handlers/cards.rs`). How does this structure enable better code organization?

**Answer:** This is just basic module management in rust. Because we want various handler files like `cards.rs` and `decks.rs` we need to have a `mod.rs` file which points to those modules and declares them as public to somebody trying to access `handlers/` in general. It would make more sense if we have a module that was only meant to serve the modules within without the need to be accessible from the outside. This module let's say `helper.rs` would not need to be declared in the main `mod.rs` file in `handlers/`. 

Similarly, if we wanted to house all of the handler functions in a single file called `handlers.rs`, we could forgo the `handlers/` directory and just build a file for declaring modules or functions with in `pub` or not `pub`. 

---

## Bonus Challenge Question

**Advanced:** Explain how the module system in Rust enables better testing strategies. How could you test the `list_cards` handler independently from the rest of the application?

**Answer:** I have only built tests in the same file as the module itself. You could do this. I think you could also build a `tests.rs` file altogether to test either various modules or singular modules. Within the tests module, you could build particular test states that you want to know if your functions work with for specialized unit testing that remains separate from actual production code.

---

*Quiz created based on Rust API development concepts including module organization, database connections, Axum framework patterns, and production-ready code practices.*
