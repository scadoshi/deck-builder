# ðŸŽ¯ JWT Middleware & Declarative Security Pop Quiz

## Multiple Choice Questions (5 questions)

### 1. What are the two main approaches we explored for JWT authentication in Axum?
A) Middleware layers vs. route guards  
B) Manual header parsing vs. custom extractors  
C) Bearer tokens vs. cookie auth  
D) Synchronous vs. asynchronous validation  

**Answer:** 

B

This one was interesting because the manual version felt more like the "custom" way at first. But at the end of the day it seemed to be more of the object-oriented way of doing things. The part where we built a custom extractor which I am still wrapping my head around seems like the more declarative approach which is super rusty.

### 2. In the custom extractor pattern, what trait does `AuthenticatedUser` implement?
A) `FromRequest<AppState>`  
B) `FromRequestParts<AppState>`  
C) `IntoResponse<AppState>`  
D) `RequestExtractor<AppState>`  

**Answer:** 

B

This is that way so that we can pass requests into a function and IF the request has a parameter which uses the type `AuthenticatedUser`, then it will force the request to have a header `Authorization` and that header must be of type `Bearer`. If either of those aren't the case, then the function will fail returning a `StatusCode::BAD_REQUEST`.


### 3. When should you return `StatusCode::BAD_REQUEST` vs `StatusCode::UNAUTHORIZED` in JWT middleware?
A) BAD_REQUEST for missing/malformed headers, UNAUTHORIZED for invalid tokens  
B) BAD_REQUEST for invalid tokens, UNAUTHORIZED for missing headers  
C) Always use UNAUTHORIZED for any auth failure  
D) Always use BAD_REQUEST for any client error  

**Answer:** 

A

`BAD_REQUEST` is for when a request is not formed how we are expecting it. 
`UNAUTHORIZED` is for when the request is correct but the json web token that they pass us does not validate successfully.


### 4. What's the main advantage of the declarative security approach over traditional middleware?
A) Better performance  
B) Type system enforces auth requirements through handler signatures  
C) Easier to debug  
D) More secure encryption  

**Answer:** 

B

Not sure that there is much of a tradeoff. Maybe it is just performance. The spirit of rustiness is a strong influence.

### 5. In our manual JWT middleware, what does `next.run(request).await` do?
A) Validates the JWT token  
B) Extracts user information  
C) Passes the original request to the next handler in the chain  
D) Returns an error response  

**Answer:** 

It passes the request onto the handler that was called. This is ran at the end of the function when authentication was found to be successful.

---

*Quiz created based on JWT middleware implementation, custom extractors, declarative security patterns, and HTTP authentication flow concepts covered during the authentication system breakthrough.* 